[
  {
    "ts": "2025-10-12T20:49:35.696341",
    "week": "2025W41",
    "area_hint": "우선순위 큐 작업 스케줄링",
    "title": "우선순위 큐 기반 작업 스케줄링 최적화",
    "summary": "작업 스케줄링에서 최소 시간을 계산하는 문제. 입력은 작업의 우선순위, 처리 시간, 최소 대기 시간으로 구성된 3개 정수. 3개 작업이 주어졌을 때, 우선순위 큐를 사용해 최소 시간을 계산하는 방법을 구현해야 합니다. 1. 우선순위 큐에 작업을 추가합니다. 2. 우선순위가 가장 높은 작업을 먼저 처리합니다. 3. 처리 시간이 끝나면 다음 작업을 처리합니다. 엣지케이스: 최소 대기 시간이 0이면 작업을 즉시 처리합니다. 예시 입력: 3 10 5 8 3 2 7 1 4 예시 출력: 22 출력 형식: 한 줄에 최소 시간을 출력한다."
  },
  {
    "ts": "2025-10-14T00:19:33.414187",
    "week": "2025W42",
    "area_hint": "구간 곱 모듈러",
    "title": "구간 곱 모듈러 변형",
    "summary": "구간 내 수열의 곱을 1000000007로 나눈 나머지 계산. 입력은 3개 정수 A, B, C (1 ≤ A ≤ 10^5, 1 ≤ B ≤ 10^5, 1 ≤ C ≤ 10^5)로 구성된 1줄. 규칙: 1) A와 B는 서로소 집합이어야 한다. 2) C는 A와 B의 최소공배수의 3배 이상이어야 한다. 3) 결과는 1000000007로 나눈 나머지. 예시 입력: 5 12 300000 예시 출력: 243255 예시 출력: 243255. 출력 형식: 한 줄에 1000000007로 나눈 나머지 값을 출력한다."
  },
  {
    "ts": "2025-10-20T10:38:06.756392",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다."
  },
  {
    "ts": "2025-10-21T17:18:57.614575",
    "week": "2025W43",
    "area_hint": "최장 증가 부분수열 변형",
    "title": "증가하는 부분수열의 최대 길이 계산",
    "summary": "문제: 주어진 수열에서 증가하는 부분수열의 최대 길이를 계산합니다. 입력: 정수 수열의 길이 N(1 ≤ N ≤ 100)과 수열 A의 N개 정수(1 ≤ A[i] ≤ 1000)가 주어집니다. 중복 허용되지 않으며, 수열은 한 줄에 입력됩니다. 규칙: 1. 동적 프로그래밍을 사용하여 각 위치에서의 최대 증가 부분수열 길이를 계산합니다. 2. 현재 위치 i에서의 최대 길이를 이전 위치 j(0 ≤ j < i)에서의 최대 길이와 비교하여 업데이트합니다. 3. 최종적으로 모든 위치에서의 최대 길이를 비교하여 최대값을 반환합니다. 엣지케이스: 수열이 내림차순이면 최대 길이는 1입니다. 예시 입력: 5 10 20 30 40 50\n예시 출력: 5\n출력 형식: 한 줄에 최대 길이를 출력합니다."
  },
  {
    "ts": "2025-10-22T22:46:02.122371",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다."
  },
  {
    "ts": "2025-10-22T22:48:55.917970",
    "week": "2025W43",
    "area_hint": "배낭 문제 소형",
    "title": "배낭 문제 소형 변형",
    "summary": "배낭에 담을 수 있는 물건 중 최대 가치를 계산하는 문제. 입력은 물건의 무게와 가치로 구성된 2개의 정수 리스트. 무게는 1부터 100까지, 가치는 1부터 1000까지. 물건은 중복하지 않음. 1. 무게가 50이하인 물건만 선택 가능. 2. 선택한 물건의 무게 합이 50이하여야 함. 3. 가치가 가장 큰 물건을 선택해야 함. 4. 무게 20, 가치 150과 무게 30, 가치 200이 있을 때, 무게 20의 물건을 선택하지 않아야 함. 예시 입력: 20 150 30 200 10 500 40 300 5 100 60 400 70 350 80 250 90 200 100 150 예시 출력: 200 예시 출력: 200 출력 형식: 한 줄에 최대 가치를 출력한다."
  },
  {
    "ts": "2025-10-22T22:49:25.896371",
    "week": "2025W43",
    "area_hint": "조합 동적계획(제약)",
    "title": "조합적 경로 최적화",
    "summary": "문제: 조합적 경로의 최소 길이를 계산하는 문제. 입력: 3개 이상의 정수 N, M, K (1 ≤ N ≤ 10, 1 ≤ M ≤ 10, 1 ≤ K ≤ 10) 및 K개의 정수 경로 길이. 규칙: 1) 경로 길이가 0이 아닌 정수만 허용. 2) 경로가 N개 이상이면 무효. 3) K개의 경로 중 최소 2개는 동일한 길이를 가져야 한다. 엣지케이스: N=10, M=10, K=10, 경로 길이 [1,2,3,4,5,6,7,8,9,10] 시 최소 경로 길이는 10. 예시 입력: 10 10 10 1 2 3 4 5 6 7 8 9 10 예시 출력: 10 출력 형식: 한 줄에 최소 경로 길이를 출력한다."
  },
  {
    "ts": "2025-10-22T23:08:40.651017",
    "week": "2025W43",
    "area_hint": "로그 파싱 집계",
    "title": "로그파일의 시간적 집계",
    "summary": "로그파일에서 특정 시간 범위 내의 메시지 수를 계산하는 문제. 입력은 정수 N(1≤N≤100)과 N개의 로그 메시지의 시간戳(1000≤T≤999999999)가 주어진다. 규칙은 다음과 같다: 1) 시간戳은 1000부터 시작하며, 1초 단위로 증가한다. 2) 메시지가 1초마다 발생하며, 시간戳가 1000의 배수일 때만 로그가 기록된다. 3) 시간 범위는 1000부터 999999999까지, 1초 단위로 계산하며, 엣지케이스는 1000초에서 1000초까지의 메시지 수가 1개이다. 예시 입력: 3 1000 1001 1002 예시 출력: 1"
  },
  {
    "ts": "2025-10-22T23:13:42.855393",
    "week": "2025W43",
    "area_hint": "부분수열 합(중복 허용)",
    "title": "중복 허용 부분수열 합 최소화",
    "summary": "중복 허용 부분수열 합의 최소값을 계산합니다. 입력은 정수 배열 arr, 길이 1~100, 중복 허용. 규칙: 1. 정수 배열의 부분수열을 선택하여 합을 구하고, 중복 허용된 수를 최소한으로 선택합니다. 2. 중복 허용된 수가 2개 이상일 때, 그 수를 1개로 취급합니다. 3. 최소 합을 찾는 데서, 중복 허용된 수가 1개 이상일 때, 그 수를 1개로 취급합니다. 4. 입력이 [1, 2, 3, 4]일 때, 최소 합은 1입니다. 예시 입력: 1 2 3 4 5 6 7 8 9 10 예시 출력: 1"
  },
  {
    "ts": "2025-10-22T23:18:53.254864",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다."
  },
  {
    "ts": "2025-10-22T23:55:50.446212",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-23T00:01:57.573512",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-23T00:08:04.658084",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-23T00:29:19.244107",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-23T00:35:25.451325",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-23T00:41:32.600841",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-23T04:42:04.017885",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-24T15:20:38.434121",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "ts": "2025-10-24T15:22:44.025930",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다.",
    "example_input": "12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10",
    "example_output": "1"
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "문자열 토큰 통계",
    "title": "문자열 토큰 통계의 비효율적 계산"
  },
  {
    "week": "2025W43",
    "idx": 2,
    "topic": "스택/덱 기반 윈도우 최댓값",
    "title": "윈도우 최댓값 계산의 실수"
  },
  {
    "week": "2025W43",
    "idx": 3,
    "topic": "간단한 세그먼트 트리",
    "title": "세그먼트 트리로 구간 합 계산"
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "라인스위핑 면적합",
    "title": "라인스위핑으로 도시 넓이 계산",
    "story_seed": "도시의 지도가 2D 평면 위에 놓여 있으며, 주요 도로가 직선으로 연결되어 있다.",
    "statement": "주어진 도로 좌표를 기반으로 도시의 넓이를 라인스위핑 알고리즘을 사용해 계산하세요."
  },
  {
    "week": "2025W43",
    "idx": 2,
    "topic": "이벤트 타임라인 압축",
    "title": "이벤트 타임라인 압축",
    "story_seed": "이벤트 관리 시스템에서 발생하는 이벤트를 시간 순서로 정렬한 후, 중복된 시간 범위를 제거하여 효율적인 타임라인을 생성하는 과정",
    "statement": "주어진 이벤트 시간 범위 리스트에서 중복된 시간 범위를 제거하고, 남은 시간 범위를 오름차순으로 정렬한 후, 최소한의 길이로 합쳐진 타임라인을 생성하세요."
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "모노톤 스택 범위합",
    "title": "모노톤 스택을 이용한 구간 합 최",
    "story_seed": "도시의 교통망에서 실시간으로 차량의 이동 경로를 추적하는 시스템이 개발되었습니다.",
    "statement": "주어진 차량 이동 경로의 구간을 모노톤 스택을 활용해 최소한의 계산으로 합계를 구하세요."
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 2,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 2,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 3,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 1,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 2,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "week": "2025W43",
    "idx": 3,
    "topic": "이벤트 로그 세션화",
    "title": "로그 세션 집계",
    "story_seed": "웹 서비스 접속 로그에서 사용자의 세션별 활동량을 집계해야 한다.",
    "statement": "타임스탬프 오름차순 로그가 주어진다. 세션 타임아웃이 G초일 때, 각 세션의 이벤트 수를 구하라."
  },
  {
    "ts": "2025-10-25T02:16:58.847075",
    "week": "2025W43",
    "area_hint": "간단 JSON 파싱 후 카운트",
    "title": "JSON 문자열 카운팅",
    "summary": "이 문제는 주어진 JSON 문자열에서 원소의 개수를 계산하는 프로그램을 작성해야 합니다. 입력은 한 줄에 여러 개의 정수로 이루어져 있으며, 각 정수가 중복될 수 있습니다. 예시 입력: 예시 입력: 10 20 -34 56 78 90 123 456 789 1000 1001 1002 1003 1004 1005. 예시 출력: 15개의 정수가 포함되어 있습니다."
  },
  {
    "ts": "2025-10-25T02:42:57.912474",
    "week": "2025W43",
    "area_hint": "아나그램 그룹화",
    "title": "문자열 아나그램 그룹화 계산하기",
    "summary": "이 문제는 문자열을 입력받아, 각 문자가 포함된 모든 가능한 단어 그룹들을 정렬하여 반환한다. 예시 입력은 한 줄에 최대 5개의 값으로 구성되며, 이 값들은 서로 다른 두 자리 수를 가진다. 예시 출력은 예시 입력과 동일한 형식을 따르며, 결과는 각 단어 그룹이 정렬된 상태로 반환된다."
  },
  {
    "ts": "2025-10-25T02:43:07.772794",
    "week": "2025W43",
    "area_hint": "행렬 지수(작은 차수)",
    "title": "행렬 지수 계산하기",
    "summary": "이 문제는 행렬의 크기와 값을 기반으로, 그에 따른 행렬의 지수를 계산하는 알고리즘을 구현해야 합니다. 입력은 행렬의 크기와 각 요소 값입니다. 예시 입력과 출력 형식을 따르며, 최대 10x10 크기로 제한됩니다. 규칙은 단계별로 명시되어 있으며, 엣지케이스를 포함합니다."
  },
  {
    "ts": "2025-10-25T02:43:28.226175",
    "week": "2025W43",
    "area_hint": "CSV 파싱 정제 후 통계",
    "title": "CSV 행 갯수 계산하기",
    "summary": "이 문제는 CSV 파일에서 각 열의 행 수를 계산하는 프로그램을 작성해야 합니다. 입력은 한 줄에 최대 5개의 값으로 구성된 리스트이며, 이 값들은 각각 다른 숫자여야 합니다. 예시 입력: [123, 'abc', 456, True, None]. 출력 형식은 단순한 정수로 이루어져야 하며, 예시 출력: 5입니다."
  },
  {
    "ts": "2025-10-25T05:30:08.109624",
    "week": "2025W43",
    "area_hint": "백업-내부",
    "title": "이중 조건 윈도우 구간 집계",
    "summary": "문제: 1차원 배열에서 길이 k의 연속 구간 중 특정 조건을 만족하는 구간의 개수를 계산한다.\n입력: 첫 줄에 정수 n, k, d(1 ≤ k ≤ n ≤ 2×10^5, 0 ≤ d ≤ 10^9). 둘째 줄에 길이 n의 정수 배열이 주어진다(각 원소 |ai| ≤ 10^9).\n규칙: 각 길이 k 구간에 대해 (i) 원소 합이 7의 배수이고, (ii) 해당 구간의 최댓값−최솟값 ≥ d 일 때 유효로 간주한다. 배열은 수정하지 않는다.\n절차: (1) 윈도우에 새 원소를 추가하고 오래된 원소를 제거하며 합을 관리한다. (2) 최대·최소는 덱 두 개로 유지한다. (3) 두 조건을 동시에 만족하면 카운트를 증가시킨다. 빈 배열이나 k>n인 경우는 0으로 처리한다.\n예시 입력: 12 4 9\n13 2 17 8 11 6 25 9 4 16 7 10\n예시 출력: 1\n출력 형식: 한 줄에 유효 구간의 개수를 출력한다."
  },
  {
    "ts": "2025-10-25T06:43:13.493635",
    "week": "2025W43",
    "area_hint": "배낭 문제 소형",
    "title": "배낭 문제 소형 변형",
    "summary": "배낭에 들어갈 수 있는 물건 중 최대 가치를 계산하는 문제. 입력은 물건의 수 n, 배낭 용량 C, 각 물건의 무게 w_i와 가치 v_i로 구성된 3개의 정수 리스트. n은 100 이하, C는 1000 이하, w_i와 v_i는 100 이하. 규칙 1: 배낭 용량을 넘지 않도록 선택. 규칙 2: 물건을 선택할 때 무게와 가치의 비율을 고려하여 최적화. 규칙 3: 무게가 0인 물건은 배낭에 포함할 수 없음. 엣지케이스: 무게가 0인 물건이 포함된 입력. 예시 입력: 3 100 10 50 20 30 30 20 예시 출력: 80 출력 형식: 한 줄에 최대 가치를 출력한다."
  },
  {
    "ts": "2025-10-25T11:27:14.490467",
    "week": "2025W43",
    "area_hint": "LRU 캐시 시뮬레이션",
    "title": "자동생성 문제"
  },
  {
    "ts": "2025-10-25T11:27:26.908552",
    "week": "2025W43",
    "area_hint": "조합 동적계획(제약)",
    "title": "자동생성 문제"
  },
  {
    "ts": "2025-10-25T11:27:40.481912",
    "week": "2025W43",
    "area_hint": "최장 증가 부분수열 변형",
    "title": "자동생성 문제"
  },
  {
    "ts": "2025-10-25T11:29:01.441328",
    "week": "2025W43",
    "area_hint": "빈도 기반 재정렬",
    "title": "자동생성 문제"
  },
  {
    "ts": "2025-10-25T11:29:15.501593",
    "week": "2025W43",
    "area_hint": "부분수열 합(중복 허용)",
    "title": "자동생성 문제"
  },
  {
    "ts": "2025-10-25T11:29:27.893885",
    "week": "2025W43",
    "area_hint": "위상 정렬(소형 DAG)",
    "title": "자동생성 문제"
  },
  {
    "ts": "2025-10-25T11:31:50.145649",
    "week": "2025W43",
    "area_hint": "행렬 지수(작은 차수)",
    "title": "{"
  },
  {
    "ts": "2025-10-25T11:31:56.969653",
    "week": "2025W43",
    "area_hint": "간단 JSON 파싱 후 카운트",
    "title": "{"
  },
  {
    "ts": "2025-10-25T11:32:03.182654",
    "week": "2025W43",
    "area_hint": "구간 곱 모듈러",
    "title": "{"
  },
  {
    "ts": "2025-10-25T11:34:13.626703",
    "week": "2025W43",
    "area_hint": "배낭 문제 소형",
    "title": "{"
  },
  {
    "ts": "2025-10-25T12:01:28.738484",
    "week": "2025W43",
    "idx": 1,
    "area": "투 포인터와 슬라이딩 윈도우",
    "title": "최소 길이 부분 배열 합"
  },
  {
    "ts": "2025-10-25T12:01:37.819752",
    "week": "2025W43",
    "idx": 2,
    "area": "비트마스킹을 이용한 집합 연산",
    "title": "과일 바구니 조합"
  },
  {
    "ts": "2025-10-25T12:01:48.512314",
    "week": "2025W43",
    "idx": 3,
    "area": "투 포인터를 이용한 부분 배열 합",
    "title": "특정 합을 갖는 부분 배열"
  },
  {
    "ts": "2025-10-28T03:34:51.400230",
    "week": "2025W44",
    "idx": 1,
    "area": "비트마스킹과 집합 연산",
    "title": "과일 조합의 비트 연산",
    "summary": "N개의 과일이 주어지고, 각 과일은 고유한 번호(1부터 N)를 가집니다. M개의 조합이 주어질 때, 각 조합은 비트마스크로 표현된 과일 집합입니다. 모든 조합을 포함하는 최소 크기의 과일 집합을 찾으세요. 입력 형식: - 첫 줄: N M (1 ≤ N ≤ 20, 1 ≤ M ≤ 100)- 다음 M줄: 각 줄은 공백으로 구분된 정수들 (첫 숫자는 k, 이후 k개의 과일 번호)출력 형식: - 최소 집합 크기 예시 입력: 5 3\n 3 1 2 3\n 2 2 4\n 2 3 5 예시 출력: 3"
  },
  {
    "ts": "2025-11-01T05:15:37.616340",
    "week": "2025W44",
    "idx": 1,
    "area": "비트마스킹을 이용한 부분집합 최적화",
    "title": "최소 비용 부분집합 선택"
  },
  {
    "ts": "2025-11-01T05:17:08.366834",
    "week": "2025W44",
    "idx": 2,
    "area": "비트 마스킹을 이용한 집합 연산",
    "title": "공통 취미 찾기"
  },
  {
    "ts": "2025-11-01T05:18:11.095710",
    "week": "2025W44",
    "idx": 3,
    "area": "투 포인터 알고리즘",
    "title": "연속된 부분 배열의 최대 합"
  },
  {
    "ts": "2025-11-01T05:26:20.170112",
    "week": "2025W44",
    "idx": 1,
    "area": "배열 슬라이딩 윈도우",
    "title": "특정 합 연속구간 개수",
    "summary": "정수 배열에서 길이 k 연속구간의 합이 m의 배수인 구간 개수를 구한다.\n예시 입력: 5 3 4\n1 2 3 4 5\n예시 출력: 2"
  },
  {
    "ts": "2025-11-01T05:43:17.279219",
    "week": "2025W44",
    "idx": 1,
    "area": "배열 슬라이딩 윈도우",
    "title": "특정 합 연속구간 개수",
    "summary": "정수 배열에서 길이 k 연속구간의 합이 m의 배수인 구간 개수를 구한다.\n예시 입력: 5 3 4\n1 2 3 4 5\n예시 출력: 2"
  },
  {
    "ts": "2025-11-01T05:44:35.222239",
    "week": "2025W44",
    "idx": 2,
    "area": "비트 마스킹과 집합 연산",
    "title": "과일 세트 조합 찾기",
    "summary": "N개의 과일이 주어지고, 각 과일은 1부터 N까지 번호가 매겨집니다. M개의 과일 세트 정보가 주어지며, 각 세트는 비트 마스크로 표현됩니다. K개의 쿼리가 주어질 때, 각 쿼리는 두 개의 과일 번호 a, b를 포함합니다. 각 쿼리에 대해 a와 b를 모두 포함하는 세트의 개수를 출력하세요.\n\n입력 형식:\n- 첫 줄: N M K (1 ≤ N ≤ 20, 1 ≤ M ≤ 1000, 1 ≤ K ≤ 1000)\n- 다음 M줄: 각 줄에 세트를 나타내는 정수(비트 마스크)\n- 다음 K줄: 각 줄에 a b (1 ≤ a, b ≤ N, a ≠ b)\n\n출력 형식:\n- 각 쿼리 결과를 한 줄에 하나씩 출력\n\n예시 입력:\n3 4 2\n5\n3\n6\n7\n1 2\n2 3\n\n예시 출력:\n2\n1"
  },
  {
    "ts": "2025-11-01T05:45:54.619046",
    "week": "2025W44",
    "idx": 3,
    "area": "해싱과 슬라이딩 윈도우",
    "title": "고유 문자 최장 부분문자열",
    "summary": "문자열 S가 주어질 때, 중복되는 문자가 없는 가장 긴 부분문자열의 길이를 찾으시오.\n\n입력 형식:\n- 첫 줄에 문자열 S (1 ≤ |S| ≤ 100,000, 알파벳 소문자만)\n\n출력 형식:\n- 중복 문자가 없는 가장 긴 부분문자열의 길이\n\n제약:\n- 문자열은 알파벳 소문자로만 구성\n- 시간 제한: 1초\n- 메모리 제한: 256MB\n\n예시 입력 1:\nabcabcbb\n\n예시 출력 1:\n3\n\n설명: \"abc\"가 길이 3으로 가장 김\n\n예시 입력 2:\nbbbbb\n\n예시 출력 2:\n1"
  },
  {
    "ts": "2025-11-01T05:45:54.620046",
    "week": "2025W44",
    "problems": [
      {
        "idx": 1,
        "area": "배열 슬라이딩 윈도우",
        "title": "특정 합 연속구간 개수",
        "summary": "정수 배열에서 길이 k 연속구간의 합이 m의 배수인 구간 개수를 구한다.\n예시 입력: 5 3 4\n1 2 3 4 5\n예시 출력: 2"
      },
      {
        "idx": 2,
        "area": "비트 마스킹과 집합 연산",
        "title": "과일 세트 조합 찾기",
        "summary": "N개의 과일이 주어지고, 각 과일은 1부터 N까지 번호가 매겨집니다. M개의 과일 세트 정보가 주어지며, 각 세트는 비트 마스크로 표현됩니다. K개의 쿼리가 주어질 때, 각 쿼리는 두 개의 과일 번호 a, b를 포함합니다. 각 쿼리에 대해 a와 b를 모두 포함하는 세트의 개수를 출력하세요.\n\n입력 형식:\n- 첫 줄: N M K (1 ≤ N ≤ 20, 1 ≤ M ≤ 1000, 1 ≤ K ≤ 1000)\n- 다음 M줄: 각 줄에 세트를 나타내는 정수(비트 마스크)\n- 다음 K줄: 각 줄에 a b (1 ≤ a, b ≤ N, a ≠ b)\n\n출력 형식:\n- 각 쿼리 결과를 한 줄에 하나씩 출력\n\n예시 입력:\n3 4 2\n5\n3\n6\n7\n1 2\n2 3\n\n예시 출력:\n2\n1"
      },
      {
        "idx": 3,
        "area": "해싱과 슬라이딩 윈도우",
        "title": "고유 문자 최장 부분문자열",
        "summary": "문자열 S가 주어질 때, 중복되는 문자가 없는 가장 긴 부분문자열의 길이를 찾으시오.\n\n입력 형식:\n- 첫 줄에 문자열 S (1 ≤ |S| ≤ 100,000, 알파벳 소문자만)\n\n출력 형식:\n- 중복 문자가 없는 가장 긴 부분문자열의 길이\n\n제약:\n- 문자열은 알파벳 소문자로만 구성\n- 시간 제한: 1초\n- 메모리 제한: 256MB\n\n예시 입력 1:\nabcabcbb\n\n예시 출력 1:\n3\n\n설명: \"abc\"가 길이 3으로 가장 김\n\n예시 입력 2:\nbbbbb\n\n예시 출력 2:\n1"
      }
    ]
  },
  {
    "ts": "2025-11-05T19:46:48.323614",
    "week": "2025W45",
    "idx": 1,
    "area": "스택을 이용한 문자열 처리",
    "title": "괄호 문자열 압축 해제",
    "summary": "숫자와 소괄호(), 대괄호[]로 이루어진 문자열이 주어집니다. 문자열에서 숫자는 반복 횟수를, 괄호 안의 문자들은 반복할 내용을 나타냅니다. 문자열을 압축 해제하는 프로그램을 작성하세요.\n\n입력 형식: 첫 줄에 테스트 케이스 수 T, 다음 각 줄에 문자열 S (1 ≤ |S| ≤ 1000)\n출력 형식: 각 테스트 케이스에 대해 압축 해제된 문자열 출력\n\n제약: 문자열은 숫자, 영문자, '(', ')', '[', ']'로만 구성\n\n예시 입력:\n2\n2(ab)3[c]\n3(a2(b))\n\n예시 출력:\nababccc\nabbabbabb"
  },
  {
    "ts": "2025-11-05T19:47:21.293543",
    "week": "2025W45",
    "idx": 2,
    "area": "투 포인터와 누적 합",
    "title": "부분 배열 최대 아름다움",
    "summary": "n개의 정수로 이루어진 배열이 주어집니다. 각 원소는 -1000 이상 1000 이하의 정수입니다. 배열의 '아름다움'은 배열의 모든 원소의 합으로 정의됩니다. 이때, 배열에서 연속된 부분 배열을 선택하여, 그 부분 배열의 아름다움을 최대로 하는 프로그램을 작성하세요.\n\n입력 형식:\n- 첫째 줄에 정수 n (1 ≤ n ≤ 100,000)이 주어집니다.\n- 둘째 줄에 n개의 정수가 공백으로 구분되어 주어집니다.\n\n출력 형식:\n- 선택한 부분 배열의 아름다움의 최댓값을 출력합니다.\n\n제약:\n- n은 1 이상 100,000 이하입니다.\n- 배열의 각 원소는 -1000 이상 1000 이하의 정수입니다.\n\n예시 입력:\n9\n3 -4 1 -3 5 -7 3 2 -1\n\n예시 출력:\n5\n(설명: 부분 배열 [5]의 합이 5로 최대입니다.)"
  },
  {
    "ts": "2025-11-05T19:48:36.332264",
    "week": "2025W45",
    "idx": 3,
    "area": "스도쿠 검증",
    "title": "부분 스도쿠 검증하기",
    "summary": "9x9 스도쿠 보드에서 3x3 부분 영역만 주어졌을 때, 해당 영역이 유효한지 검증하는 문제입니다.\n\n입력 형식:\n- 3줄에 걸쳐 3x3 숫자 행렬 입력 (각 줄은 공백으로 구분된 3개의 정수)\n- 숫자는 1부터 9까지의 정수\n\n출력 형식:\n- 부분 영역이 유효하면 \"VALID\", 아니면 \"INVALID\" 출력\n- 유효 조건: 1부터 9까지의 숫자가 중복 없이 모두 존재\n\n예시 입력 1:\n1 2 3\n4 5 6\n7 8 9\n\n예시 출력 1:\nVALID\n\n예시 입력 2:\n1 2 3\n4 5 6\n7 8 7\n\n예시 출력 2:\nINVALID"
  },
  {
    "ts": "2025-11-05T19:48:36.333264",
    "week": "2025W45",
    "problems": [
      {
        "idx": 1,
        "area": "스택을 이용한 문자열 처리",
        "title": "괄호 문자열 압축 해제",
        "summary": "숫자와 소괄호(), 대괄호[]로 이루어진 문자열이 주어집니다. 문자열에서 숫자는 반복 횟수를, 괄호 안의 문자들은 반복할 내용을 나타냅니다. 문자열을 압축 해제하는 프로그램을 작성하세요.\n\n입력 형식: 첫 줄에 테스트 케이스 수 T, 다음 각 줄에 문자열 S (1 ≤ |S| ≤ 1000)\n출력 형식: 각 테스트 케이스에 대해 압축 해제된 문자열 출력\n\n제약: 문자열은 숫자, 영문자, '(', ')', '[', ']'로만 구성\n\n예시 입력:\n2\n2(ab)3[c]\n3(a2(b))\n\n예시 출력:\nababccc\nabbabbabb"
      },
      {
        "idx": 2,
        "area": "투 포인터와 누적 합",
        "title": "부분 배열 최대 아름다움",
        "summary": "n개의 정수로 이루어진 배열이 주어집니다. 각 원소는 -1000 이상 1000 이하의 정수입니다. 배열의 '아름다움'은 배열의 모든 원소의 합으로 정의됩니다. 이때, 배열에서 연속된 부분 배열을 선택하여, 그 부분 배열의 아름다움을 최대로 하는 프로그램을 작성하세요.\n\n입력 형식:\n- 첫째 줄에 정수 n (1 ≤ n ≤ 100,000)이 주어집니다.\n- 둘째 줄에 n개의 정수가 공백으로 구분되어 주어집니다.\n\n출력 형식:\n- 선택한 부분 배열의 아름다움의 최댓값을 출력합니다.\n\n제약:\n- n은 1 이상 100,000 이하입니다.\n- 배열의 각 원소는 -1000 이상 1000 이하의 정수입니다.\n\n예시 입력:\n9\n3 -4 1 -3 5 -7 3 2 -1\n\n예시 출력:\n5\n(설명: 부분 배열 [5]의 합이 5로 최대입니다.)"
      },
      {
        "idx": 3,
        "area": "스도쿠 검증",
        "title": "부분 스도쿠 검증하기",
        "summary": "9x9 스도쿠 보드에서 3x3 부분 영역만 주어졌을 때, 해당 영역이 유효한지 검증하는 문제입니다.\n\n입력 형식:\n- 3줄에 걸쳐 3x3 숫자 행렬 입력 (각 줄은 공백으로 구분된 3개의 정수)\n- 숫자는 1부터 9까지의 정수\n\n출력 형식:\n- 부분 영역이 유효하면 \"VALID\", 아니면 \"INVALID\" 출력\n- 유효 조건: 1부터 9까지의 숫자가 중복 없이 모두 존재\n\n예시 입력 1:\n1 2 3\n4 5 6\n7 8 9\n\n예시 출력 1:\nVALID\n\n예시 입력 2:\n1 2 3\n4 5 6\n7 8 7\n\n예시 출력 2:\nINVALID"
      }
    ]
  },
  {
    "ts": "2025-11-10T17:25:31.399375",
    "week": "2025W46",
    "idx": 1,
    "area": "문자열 패턴 매칭",
    "title": "특정 패턴 찾기 게임",
    "summary": "길이가 N인 문자열 S가 주어집니다. 이 문자열에서 'AB' 패턴과 'BA' 패턴이 각각 몇 번 나타나는지 세어야 합니다. 단, 두 패턴이 겹치는 부분은 중복으로 세지 않습니다.\n\n입력 형식:\n- 첫째 줄: 문자열 S (1 ≤ |S| ≤ 100,000)\n- S는 알파벳 대문자로만 구성\n\n출력 형식:\n- AB 패턴 개수와 BA 패턴 개수를 공백으로 구분하여 출력\n\n제약:\n- 시간 제한: 1초\n- 메모리 제한: 256MB\n\n예시 입력 1:\nABABA\n\n예시 출력 1:\n1 1\n\n예시 입력 2:\nBABAB\n\n예시 출력 2:\n1 1\n\n예시 입력 3:\nAAAABBBB\n\n예시 출력 3:\n0 0"
  },
  {
    "ts": "2025-11-10T17:27:02.830253",
    "week": "2025W46",
    "idx": 2,
    "area": "그래프 탐색과 이분 매칭",
    "title": "도서관 좌석 배정 최적화",
    "summary": "도서관에 N개의 좌석과 M명의 학생이 있습니다. 각 학생은 특정 시간대에만 도서관을 이용할 수 있습니다. 시간대는 1부터 T까지로 구분됩니다. 각 학생은 자신이 이용 가능한 시간대에 빈 좌석이 있으면 앉을 수 있습니다. 한 학생은 하나의 좌석에만 앉을 수 있고, 한 좌석에는 한 시간대에 한 명의 학생만 앉을 수 있습니다. 최대 몇 명의 학생을 좌석에 배정할 수 있는지 구하세요.\n\n입력 형식:\n- 첫째 줄: N M T (1 ≤ N, M ≤ 100, 1 ≤ T ≤ 50)\n- 다음 M줄: 각 학생의 이용 가능 시간대 정보 (K개 시간대, 공백 구분)\n\n출력 형식:\n- 최대 배정 가능 학생 수\n\n예시 입력:\n3 4 5\n1 3 5\n2 4\n1 2 3\n3 4 5\n\n예시 출력:\n3"
  },
  {
    "ts": "2025-11-10T17:28:53.194126",
    "week": "2025W46",
    "idx": 3,
    "area": "그래프 탐색 최적 경로",
    "title": "배달 최소 시간 계산",
    "summary": "N개의 마을이 있고, 각 마을은 도로로 연결되어 있습니다. 배달원이 1번 마을에서 시작하여 모든 마을을 방문한 후 다시 1번 마을로 돌아와야 합니다. 각 도로를 통과하는데 걸리는 시간이 주어질 때, 배달원이 모든 마을을 방문하는데 걸리는 최소 시간을 구하세요.\n\n입력 형식:\n- 첫째 줄: 마을 수 N (2 ≤ N ≤ 10)\n- 다음 N줄: N개의 정수로 구성된 인접 행렬 (0은 같은 마을, 양의 정수는 이동 시간)\n\n출력 형식:\n- 최소 이동 시간\n\n제약 조건:\n- 모든 마을은 연결되어 있음\n- 이동 시간은 1 이상 100 이하\n- 한 마을을 여러 번 방문할 수 있지만, 모든 마을을 최소 한 번은 방문해야 함\n\n예시 입력:\n4\n0 10 15 20\n10 0 35 25\n15 35 0 30\n20 25 30 0\n\n예시 출력:\n80"
  },
  {
    "ts": "2025-11-10T17:28:53.196126",
    "week": "2025W46",
    "problems": [
      {
        "idx": 1,
        "area": "문자열 패턴 매칭",
        "title": "특정 패턴 찾기 게임",
        "summary": "길이가 N인 문자열 S가 주어집니다. 이 문자열에서 'AB' 패턴과 'BA' 패턴이 각각 몇 번 나타나는지 세어야 합니다. 단, 두 패턴이 겹치는 부분은 중복으로 세지 않습니다.\n\n입력 형식:\n- 첫째 줄: 문자열 S (1 ≤ |S| ≤ 100,000)\n- S는 알파벳 대문자로만 구성\n\n출력 형식:\n- AB 패턴 개수와 BA 패턴 개수를 공백으로 구분하여 출력\n\n제약:\n- 시간 제한: 1초\n- 메모리 제한: 256MB\n\n예시 입력 1:\nABABA\n\n예시 출력 1:\n1 1\n\n예시 입력 2:\nBABAB\n\n예시 출력 2:\n1 1\n\n예시 입력 3:\nAAAABBBB\n\n예시 출력 3:\n0 0"
      },
      {
        "idx": 2,
        "area": "그래프 탐색과 이분 매칭",
        "title": "도서관 좌석 배정 최적화",
        "summary": "도서관에 N개의 좌석과 M명의 학생이 있습니다. 각 학생은 특정 시간대에만 도서관을 이용할 수 있습니다. 시간대는 1부터 T까지로 구분됩니다. 각 학생은 자신이 이용 가능한 시간대에 빈 좌석이 있으면 앉을 수 있습니다. 한 학생은 하나의 좌석에만 앉을 수 있고, 한 좌석에는 한 시간대에 한 명의 학생만 앉을 수 있습니다. 최대 몇 명의 학생을 좌석에 배정할 수 있는지 구하세요.\n\n입력 형식:\n- 첫째 줄: N M T (1 ≤ N, M ≤ 100, 1 ≤ T ≤ 50)\n- 다음 M줄: 각 학생의 이용 가능 시간대 정보 (K개 시간대, 공백 구분)\n\n출력 형식:\n- 최대 배정 가능 학생 수\n\n예시 입력:\n3 4 5\n1 3 5\n2 4\n1 2 3\n3 4 5\n\n예시 출력:\n3"
      },
      {
        "idx": 3,
        "area": "그래프 탐색 최적 경로",
        "title": "배달 최소 시간 계산",
        "summary": "N개의 마을이 있고, 각 마을은 도로로 연결되어 있습니다. 배달원이 1번 마을에서 시작하여 모든 마을을 방문한 후 다시 1번 마을로 돌아와야 합니다. 각 도로를 통과하는데 걸리는 시간이 주어질 때, 배달원이 모든 마을을 방문하는데 걸리는 최소 시간을 구하세요.\n\n입력 형식:\n- 첫째 줄: 마을 수 N (2 ≤ N ≤ 10)\n- 다음 N줄: N개의 정수로 구성된 인접 행렬 (0은 같은 마을, 양의 정수는 이동 시간)\n\n출력 형식:\n- 최소 이동 시간\n\n제약 조건:\n- 모든 마을은 연결되어 있음\n- 이동 시간은 1 이상 100 이하\n- 한 마을을 여러 번 방문할 수 있지만, 모든 마을을 최소 한 번은 방문해야 함\n\n예시 입력:\n4\n0 10 15 20\n10 0 35 25\n15 35 0 30\n20 25 30 0\n\n예시 출력:\n80"
      }
    ]
  },
  {
    "ts": "2025-11-18T01:30:38.771638",
    "week": "2025W47",
    "idx": 1,
    "area": "슬라이딩 윈도우 최적화",
    "title": "최소 고유값 부분배열 찾기",
    "summary": "정수 배열 arr와 정수 k가 주어집니다. arr의 길이가 k인 연속된 부분배열 중에서 고유한 정수의 개수가 가장 작은 부분배열의 시작 인덱스를 찾으세요. \n\n입력 형식: 첫 줄에 n과 k (1 ≤ k ≤ n ≤ 10^5), 다음 줄에 n개의 정수 arr[i] (1 ≤ arr[i] ≤ 10^9)\n출력 형식: 고유한 정수의 개수가 가장 작은 부분배열의 시작 인덱스(0-based), 여러 개라면 가장 작은 인덱스\n\n예시 입력:\n8 3\n2 3 2 1 1 2 3 1\n\n예시 출력:\n3\n\n설명: 길이 3인 부분배열 [2,1,1]은 고유한 값이 2개(1,2)로 가장 적습니다."
  },
  {
    "ts": "2025-11-18T01:30:51.565847",
    "week": "2025W47",
    "idx": 2,
    "area": "슬라이딩 윈도우와 해시맵",
    "title": "최대 고유값 부분배열 합",
    "summary": "정수 배열에서 길이가 k인 부분배열 중 서로 다른 정수의 개수가 최대인 부분배열들의 합 중 최댓값을 구하세요.\n\n입력 형식:\n- 첫 줄: n k (1 ≤ k ≤ n ≤ 100,000)\n- 다음 줄: n개의 정수 (각 정수는 -10^9 이상 10^9 이하)\n\n출력 형식:\n- 조건을 만족하는 부분배열의 합 중 최댓값\n\n예시 입력:\n6 3\n1 2 3 2 1 4\n\n예시 출력:\n6\n\n설명: 길이 3인 부분배열 중 서로 다른 정수의 개수가 최대인 것은 [1,2,3], [2,3,2], [3,2,1], [2,1,4]로 모두 2가지 이상의 고유값을 가집니다. 이 중 합이 최대인 [1,2,3]의 합은 6입니다."
  },
  {
    "ts": "2025-11-18T01:31:53.729964",
    "week": "2025W47",
    "idx": 3,
    "area": "비트 마스킹을 이용한 부분집합 최적화",
    "title": "과일 바구니 최대 가치",
    "summary": "N개의 과일이 주어지며, 각 과일은 무게와 가치를 가지고 있습니다. 바구니에 최대 K개의 과일을 담을 수 있을 때, 바구니의 총 무게가 M을 넘지 않으면서 가치의 합을 최대화하는 방법을 찾으세요.\n\n입력 형식:\n- 첫째 줄: N M K (1 ≤ N ≤ 20, 1 ≤ M ≤ 1000, 1 ≤ K ≤ N)\n- 다음 N줄: 각 줄에 w_i v_i (1 ≤ w_i ≤ 100, 1 ≤ v_i ≤ 1000)\n\n출력 형식:\n- 최대 가치 합\n\n제약:\n- N이 최대 20이므로 비트 마스킹으로 모든 경우의 수를 탐색 가능\n- 선택한 과일의 개수가 K개를 넘지 않아야 함\n- 총 무게가 M을 넘지 않아야 함\n\n예시 입력:\n4 10 2\n3 8\n5 12\n2 5\n4 10\n\n예시 출력:\n18"
  },
  {
    "ts": "2025-11-18T01:31:53.731964",
    "week": "2025W47",
    "problems": [
      {
        "idx": 1,
        "area": "슬라이딩 윈도우 최적화",
        "title": "최소 고유값 부분배열 찾기",
        "summary": "정수 배열 arr와 정수 k가 주어집니다. arr의 길이가 k인 연속된 부분배열 중에서 고유한 정수의 개수가 가장 작은 부분배열의 시작 인덱스를 찾으세요. \n\n입력 형식: 첫 줄에 n과 k (1 ≤ k ≤ n ≤ 10^5), 다음 줄에 n개의 정수 arr[i] (1 ≤ arr[i] ≤ 10^9)\n출력 형식: 고유한 정수의 개수가 가장 작은 부분배열의 시작 인덱스(0-based), 여러 개라면 가장 작은 인덱스\n\n예시 입력:\n8 3\n2 3 2 1 1 2 3 1\n\n예시 출력:\n3\n\n설명: 길이 3인 부분배열 [2,1,1]은 고유한 값이 2개(1,2)로 가장 적습니다."
      },
      {
        "idx": 2,
        "area": "슬라이딩 윈도우와 해시맵",
        "title": "최대 고유값 부분배열 합",
        "summary": "정수 배열에서 길이가 k인 부분배열 중 서로 다른 정수의 개수가 최대인 부분배열들의 합 중 최댓값을 구하세요.\n\n입력 형식:\n- 첫 줄: n k (1 ≤ k ≤ n ≤ 100,000)\n- 다음 줄: n개의 정수 (각 정수는 -10^9 이상 10^9 이하)\n\n출력 형식:\n- 조건을 만족하는 부분배열의 합 중 최댓값\n\n예시 입력:\n6 3\n1 2 3 2 1 4\n\n예시 출력:\n6\n\n설명: 길이 3인 부분배열 중 서로 다른 정수의 개수가 최대인 것은 [1,2,3], [2,3,2], [3,2,1], [2,1,4]로 모두 2가지 이상의 고유값을 가집니다. 이 중 합이 최대인 [1,2,3]의 합은 6입니다."
      },
      {
        "idx": 3,
        "area": "비트 마스킹을 이용한 부분집합 최적화",
        "title": "과일 바구니 최대 가치",
        "summary": "N개의 과일이 주어지며, 각 과일은 무게와 가치를 가지고 있습니다. 바구니에 최대 K개의 과일을 담을 수 있을 때, 바구니의 총 무게가 M을 넘지 않으면서 가치의 합을 최대화하는 방법을 찾으세요.\n\n입력 형식:\n- 첫째 줄: N M K (1 ≤ N ≤ 20, 1 ≤ M ≤ 1000, 1 ≤ K ≤ N)\n- 다음 N줄: 각 줄에 w_i v_i (1 ≤ w_i ≤ 100, 1 ≤ v_i ≤ 1000)\n\n출력 형식:\n- 최대 가치 합\n\n제약:\n- N이 최대 20이므로 비트 마스킹으로 모든 경우의 수를 탐색 가능\n- 선택한 과일의 개수가 K개를 넘지 않아야 함\n- 총 무게가 M을 넘지 않아야 함\n\n예시 입력:\n4 10 2\n3 8\n5 12\n2 5\n4 10\n\n예시 출력:\n18"
      }
    ]
  }
]